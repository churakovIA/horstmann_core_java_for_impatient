# Exercises
### Core Java for the impatient. Cay S. Horstmann    

[__Chapter 1.__ Fundamental programming structures](#ch1) \
[__Chapter 2.__ Object-oriented programming](#ch2) \
[__Chapter 3.__ Interfaces and lambda expressions](#ch3) \
[__Chapter 4.__ Inheritance and reflection](#ch4) 

#### <a name="ch1"></a> Chapter 1. Fundamental programming structures
[home](#exercises)

1. Напишите программу, вводящую целочисленное значение и выводящую его в двоичной, восьмеричной и шестнадцатеричной форме. Организуйте вывод обратного значения в виде шестнадцатеричного числа с плавающей точкой.
1. Напишите программу, вводящую целочисленное (как положительное, так и отрицательное) значение угла и нормализующую его в пределах от 0 до 359 градусов. Попробуйте сделать это сначала с помощью операции %, а затем метода floorMod().
1. Напишите программу, вводящую три целочисленных значения и выводящую самое большое из них, используя только условную операцию. Сделайте то же самое с помощью метода Math.шах ().
Напишите программу, выводящую наименьшее и наибольшее положительные значения типа double. Подсказка: воспользуйтесь методом Math.nextUp () из прикладного программного интерфейса Java API.
1. Что произойдет, если привести числовое значение типа double к значению типа int, которое больше самого большого значения типа int? Попробуйте сделать это.
1. Напишите программу, вычисляющую факториал п! = 1 х 2 * . . . х п, используя класс Biglnteger. Вычислите факториал числа 1000.
1. Напишите программу, вводящую два числа в пределах от 0 до 65535, сохраняющую их в переменных типа short и вычисляющую их сумму, разность, произведение, частное и остаток без знака, не преобразуя эти величины в тип int.
1. Напишите программу, вводящую символьную строку и выводящую все ее непустые подстроки.
1. В разделе 1.5.3 был приведен пример сравнения двух символьных строк s и t при вызове метода s. equals (t), но не с помощью операции s != t. Придумайте другой пример, в котором не применяется метод substring ().
1. Напишите программу, составляющую произвольную символьную строку из букв и цифр, генерируя произвольное значение типа long и выводя его по основанию 36.
1. Напишите программу, вводящую текстовую строку и выводящую все символы, не представленные в коде ASCII, вместе с их значениями в Юникоде.
1. В состав комплекта разработки Java Development Kit входит архивный файл src. zip с исходным кодом библиотеки Java. Разархивируйте этот файл и с помощью избранного вами инструментального средства для поиска текста найдите в этом исходном коде примеры применения последовательностей операторов break и continue с меткой. Выберите один из этих примеров и перепишите его без оператора с меткой.
1. Напишите программу, выбирающую и выводящую лотерейную комбинацию из шести отдельных чисел в пределах от 1 до 49. Чтобы выбрать шесть отдельных чисел, начните со списочного массива, заполняемого числами от 1 до 49. Выберите произвольный индекс и удалите элемент массива. Повторите эти действия шесть раз подряд. Выведите полученный результат в отсортированном порядке.
1. Напишите программу, вводящую двумерный массив целочисленных значений и определяющую, содержится ли в нем магический квадрат (т.е. одинаковая сумма значений во всех строках, столбцах и диагоналях). Принимая строки вводимых данных, разбивайте их на отдельные целочисленные значения, прекратив этот процесс, когда пользователь введет пустую строку. Например, на следующие вводимые данные: \
   16 3 2 13 \
   3 10 11 8 \
   9 6 7 12 \
   4 15 14 1   
   (Пустая строка) \
   программа должна ответить утвердительно.
1. Напишите программу, сохраняющую треугольник Паскаля вплоть до заданной величины п в переменной типа ArrayList<ArrayList<Integer».
1. Усовершенствуйте упоминавшийся ранее метод average () таким образом, чтобы он вызывался хотя бы с одним параметром.

#### <a name="ch2"></a> Chapter 2. Object-oriented programming
[home](#exercises)

1. Измените представленную в этой главе программу вывода календаря таким образом, чтобы неделя начиналась с воскресенья. Кроме того, организуйте перевод на новую строку в конце предыдущей, но только один раз.
2. Проанализируйте метод nextlnt () из класса Scanner. Является ли он методом доступа или модифицирующим методом и почему? А что можно сказать о методе nextlnt () из класса Random?
3. Может ли модифицирующий метод вообще возвращать что-нибудь, кроме типа void? Можно ли создать метод доступа с возвращаемым типом void, т.е. ничего фактически не возвращающий? Приведите по возможности примеры таких методов.
4. Почему в Java нельзя реализовать метод, меняющий местами содержимое двух переменных типа int? Вместо этого напишите метод, меняющий местами содержимое двух объектов типа IntHolder. (Описание этого малоизвестного класса можно найти в документации на прикладной программный интерфейс Java API.) Можно ли поменять местами содержимое двух объектов типа Integer?
5. Реализуйте неизменяемый класс Point, описывающий точку на плоскости. Предоставьте его конструктор, чтобы задать конкретную точку; конструктор без аргументов, чтобы задать точку в начале координат; а также методы getX (), getY (), translate () и scale (). В частности, метод translate () должен перемещать точку на определенное расстояние в направлении координат х и у, а метод scale () — изменять масштаб по обеим координатам на заданный коэффициент. Реализуйте эти методы таким образом, чтобы они возвращали новые точки в качестве результата. Например, в следующей строке кода:
Point р = new Point(3, 4).translate(1, 3).scale(0.5); в переменной р должна быть установлена точка с координатами (2, 3,5).
6. Повторите предыдущее упражнение, но на этот раз сделайте методы trans late () и scale () модифицирующими.
7. Введите документирующие комментарии в обе версии класса Point из предыдущих упражнений.
8. В предыдущих упражнениях для предоставления конструкторов и методов получения из класса Point пришлось писать часто повторяющийся код. В большинстве ИСР имеются средства, упрощающие написание повторяющегося шаблонного кода. Имеются ли такие средства в применяемой вами ИСР?
9. Реализуйте класс Саг, моделирующий передвижение автомобиля на бензиновом топливе по оси х. Предоставьте методы для передвижения автомобиля на заданное количество километров, заполнения топливного бака заданным количеством литров бензина, вычисления расстояния, пройденного от начала координат, а также уровня топлива в баке. Укажите расход топлива (в км/л) в качестве параметра конструктора данного класса. Должен ли этот класс быть неизменяемым и почему?
10. Предоставьте в классе RandomNumbers два статических метода типа random Element, получающих произвольный элемент из обычного или списочного массива целочисленных значений. (Если обычный или списочный массив пуст, должен быть возвращен нуль.) Почему эти методы нельзя сделать методами экземпляра типа t [ ] или ArrayList<Integer>?
11. Перепишите класс Са1, чтобы использовать в нем статический импорт классов
System и LocalDate.
12. Создайте исходный файл HelloWorld. java, где класс HelloWorld объявляется в пакете chOl.secOl. Разметите его в каком-нибудь каталоге, но только не в подкаталоге chOl/secOl. Выполните из этого каталога команду javac HelloWorld. java. Получите ли вы в итоге файл класса и где именно? Затем выполните команду java HelloWorld. Что при этом произойдет и почему? (Подсказка: выполните команду javap HelloWorld и проанализируйте полученное предупреждающее сообщение.) И наконец, попробуйте выполнить команду javac -d . HelloWorld. java. Почему такой способ лучше?
13. Загрузите архивный ]AR-файл с библиотекой OpenCSV по адресу http:// opencsv.sourceforge.net. Напишите класс с методом main() для чтения избранных файлов формата CSV и вывода некоторого их содержимого. Соответствующий образец кода можно найти на веб-сайте библиотеки OpenCSV по указанному выше адресу. А поскольку вы еще не научились обрабатывать исключения, го воспользуйтесь следующим заголовком для метода main ():
public static void main(String[] args) throws Exception
Назначение данного упражнения — не сделать что-нибудь полезное с файлами формата CSV, но поупражняться в применении библиотеки, предоставляемой в упомянутом выше архивном JAR-файле.
14. Скомпилируйте класс Network, представленный в этой главе. Обратите внимание на то, что файл внутреннего класса называется Network$Member.class. Воспользуйтесь утилитой javap, чтобы исследовать сгенерированный код. Так, по следующей команде:
javap -private имяКласса
выводятся методы и переменные экземпляра. Выявите среди выводимых результатов ссылку на объемлющий класс. (В Linux и Mac OS X перед знаком $ в имени класса следует указать знак \ при выполнении утилиты javap.)
15. Реализуйте полностью класс Invoice, представленный в разделе 2.6.1. Предоставьте метод, выводящий счет-фактуру, и демонстрационную версию про- фа ммы, составляющей и выводящей образец счета-фактуры.
16. Реализуйте в классе Queue неограниченную очередь символьных строк. Предоставьте метод add () для ввода элемента в хвост очереди и метод remove () для удаления элемента из головы очереди. Организуйте хранение элементов в виде связного списка узлов, создав вложенный класс Node. Должен ли этот класс быть статическим?
17. Предоставьте итератор — объект, извлекающий по порядку элементы очереди из предыдущего упражнения. Сделайте класс Iterator вложенным и определите в нем методы next () и hasNext (). Определите в классе Queue метод iterator (), возвращающий ссылку на объект Queue .Iterator. Должен ли внутренний класс Iterator быть статическим?

#### <a name="ch3"></a> Chapter 3. Interfaces and lambda expressions
[home](#exercises)

1. Предоставьте интерфейс Measurable с методом double getMeasure (), измеряющим объект определенным образом. Создайте класс Employee, реализующий интерфейс Measurable. Предоставьте метод double average (Measurable [ ] objects), вычисляющий среднюю меру. Воспользуйтесь им для расчета средней зарплаты в массиве работников.
2. Продолжите предыдущее упражнение, предоставив метод Measurable largest (Measurable [ ] objects). Воспользуйтесь им, чтобы выяснить имя работника с самой высокой зарплатой. Зачем требуется приведение типов?
3. Каковы все супертипы для типа String, Scanner или ImageOutputStream? Следует иметь в виду, что у каждого типа имеется свой супертип. Класс или интерфейс без явно объявленного супертипа имеет супертип Object.
4. Реализуйте статический метод of () из интерфейса IntSequence, возвращающий последовательность из передаваемых ему аргументов. Например, в результате вызова метода IntSequence.of (3, 1, 4, 1, 5, 9) возвращается последовательность из шести значений. В качестве дополнительного задания организуйте возврат экземпляра анонимного внутреннего класса.
5. Реализуйте статический метод constant () из интерфейса IntSequence, возвращающий бесконечную последовательность констант. Например, в результате вызова IntSequence. constant (1) возвращается бесконечная последовательность 111. . .. В качестве дополнительного задания сделайте то же самое с помощью лямбда-выражения.
6. В этом упражнении вам предстоит выяснить, что произойдет, если ввести метод в интерфейс. В версии Java 7 создайте класс DigitSequence, реализующий интерфейс Iterator<Integer>, а не IntSequence. Предоставьте методы hasNext (), next () и ничего не делающий метод remove (). Напишите программу, выводящую элементы интерфейса. В версии Java 8 интерфейс Iterator был дополнен методом f orEachRemaining (). Будет ли ваш код по-прежнему компилироваться при переходе к версии Java 8? Если вы введете свой класс в архивный JAR-файл, не перекомпилировав его, будет ли он нормально действовать в версии Java 8? Что произойдет, если вызвать метод forEachRemaining () ? Кроме того, метод remove () стал методом по умолчанию в версии Java 8, генерируя исключение типа UnsupportedOperationException. Что произойдет, если вы вызовете метод remove () для экземпляра своего класса?
7. Реализуйте метод void luckySort(ArrayList<String> strings, Comparator <String> comp), вызывающий метод Collections . shuffle () для списочного массива до тех пор, пока элементы этого массива располагаются в возрастающем порядке, задаваемом компаратором.
8. Создайте класс Greeter, реализующий интерфейс Runnable, метод которого run () выводит п раз сообщение "Hello, " + target, где п и target — параметры, устанавливаемые в конструкторе. Получите два экземпляра этого класса с разными сообщениями и выполните их параллельно в двух потоках.
9. Реализуйте следующие методы:
public static void runTogether(Runnable... tasks) public static void runlnOrder(Runnable... tasks)
Первый метод должен выполнять каждую задачу в отдельном потоке и возвращать полученный результат, а второй метод — все методы в текущем потоке и возвращать полученный результат по завершении последнего метода.
10. Используя методы listFiles (FileFilter) и isDirectory из класса java.
io.File, напишите метод, возвращающий все подкаталоги из заданного каталога. Воспользуйтесь для этой цели лямбда-выражением вместо объекта типа FileFilter. Сделайте то же самое, используя ссылку на метод и анонимный внутренний класс.
11. Используя метод list (FilenameFilter) из класса java. io. File, напишите метод, возвращающий все файлы из заданного каталога с указанным расширением. Воспользуйтесь для этой цели лямбда-выражением вместо объекта типа FilenameFilter. Какая переменная из объемлющей области действия захватывается лямбда-выражением?
12. Если задан массив объектов типа File, отсортируйте его таким образом, чтобы каталоги следовали перед файлами, а в каждой группе отсортируйте элементы по пути к ним. Воспользуйтесь лямбда-выражением, чтобы указать компаратор типа Comparator.
13. Напишите метод, принимающий массив экземпляров типа Runnable и возвращающий экземпляр типа Runnable, метод которого run () выполняет их по порядку. Организуйте возврат лямбда-выражения.
14. Организуйте вызов метода Arrays. sort (), сортирующего работников сначала по зарплате, а затем по имени. Воспользуйтесь для этой цели методом Comparator. thenComparing (). Затем организуйте сортировку в обратном порядке.
15. Реализуйте локальный класс RandomSequence, упоминавшийся в разделе 3.9.1, как вложенный класс за пределами метода randomInts().

#### <a name="ch4"></a> Chapter 4. Inheritance and reflection
[home](#exercises)

1. Определите класс Point с конструктором Point (double х, double у) и методами доступа getX(), getY (). Определите также подкласс LabeledPoint с конструктором LabeledPoint(String label, double x, double y) pi методом доступа getLabel ().
2. Определите методы toString (), equals () и hashCode () для классов из предыдущего упражнения.
3. Объявите как protected переменные экземпляра х и у из класса Point в упражнении 1. Продемонстрируйте, что эти переменные доступны классу LabeledPoint только в его экземплярах.
4. Определите абстрактный класс Shape с переменной экземпляра класса Point; конструктором и конкретным методом public void moveBy (double dx, double dy), перемещающим точку на заданное расстояние; а также абстрактным классом public Point getCenter(). Предоставьте конкретные подклассы Circle, Rectangle, Line с конструкторами public Circle (Point center, double radius), public Rectangle(Point topLeft, double width, double height) и public Line (Point from, Point to).
5. Определите методы clone () в классах из предыдущего упражнения.
6. Допустим, что в методе I tern, equals (), представленном в разделе 4.2.2, используется проверка с помощью операции instanceof. Реализуйте метод Discountedltem. equals () таким образом, чтобы выполнять в нем сравнение только с суперклассом, если его параметр otherObject относится к типу Item, но с учетом скидки, если эго тип Discountedltem. Продемонстрируйте, что этот метод сохраняет симметричность, но не транзитивность, т.е. способность обнаруживать сочетание товаров по обычной цене и со скидкой, чтобы делать вызовы х. equals (у) и у .equals (z), но не х. equals (z).
7. Определите перечислимый тип для восьми комбинаций основных цветов —
BLACK, RED, BLUE, GREEN, CYAN, MAGENTA, YELLOW, WHITE — с методами getRed(), getGreen() ngetBlue().
8. В классе Class имеются шесть методов, возвращающих строковое представление типа, описываемого объектом типа Class. Чем отличается их применение к массивам, обобщенным типам, внутренним классам и примитивным типам?
9. Напишите "универсальный" метод toString (), в котором применяется рефлексия для получения символьной строки со всеми переменными экземпляра объекта. В качестве дополнительного задания можете организовать обработку циклических ссылок.
10. Воспользуйтесь примером кода из раздела 4.5.1 для перечисления всех методов из класса типа int [ ]. В качестве дополнительного задания можете выявить один метод, обсуждавшийся в этой главе, как неверно описанный.
11. Напишите программу, выводящую сообщение "Hello, World", воспользовавшись рефлексией для поиска поля out в классе java.lang.System и методом invoke () для вызова метода println ().
12. Определите отличие в производительносги обычного вызова метода от его вызова через рефлексию.
13. Напишите метод, выводящий таблицу значений из любого объекта типа Met hod, описывающего метод с параметром типа double или Double. Помимо объекта типа Method, этот метод должен принимать нижний и верхний предел, а также величину шага. Продемонстрируйте свой метод, выведя таблицы для методов Math. sqrt () и Double. toHexString (). Напишите еще один вариант данного метода, но на этот раз воспользуйтесь объектом типа Double Function <0bject> вместо объекта типа Method (см. раздел 3.6.2). Сопоставьте безопасность, эффективность и удобство обоих вариантов данного метода.